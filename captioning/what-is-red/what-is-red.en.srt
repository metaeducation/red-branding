1
00:00:10,593 --> 00:00:14,410
Our next speaker is Nenad Rakocevic

2
00:00:14,410 --> 00:00:17,039
who will be telling us "What is Red"

3
00:00:17,039 --> 00:00:22,496
(applause)

4
00:00:22,886 --> 00:00:27,767
Thanks, Gregg. And thanks to all the people

5
00:00:27,767 --> 00:00:31,908
that donated to pay the cost for my trip

6
00:00:31,908 --> 00:00:33,728
so I could make it.

7
00:00:33,728 --> 00:00:36,932
I've made a lot of Red presentations

8
00:00:36,932 --> 00:00:43,013
but newcomers to Red are still coming to me

9
00:00:43,013 --> 00:00:45,517
with this simple question:

10
00:00:45,517 --> 00:00:47,400
just "What is Red"

11
00:00:47,400 --> 00:00:50,166
because the project has many aspects

12
00:00:50,166 --> 00:00:51,741
and I can understand that.

13
00:00:51,741 --> 00:00:54,042
So I'll try in this presentation to give you

14
00:00:54,042 --> 00:00:58,673
a good view of every part of the project.

15
00:00:58,673 --> 00:01:02,522
So let's start by an overview of the problem.

16
00:01:02,522 --> 00:01:06,517
It's not a picture of my brain cells.

17
00:01:06,517 --> 00:01:10,566
It's a computer model of a global map

18
00:01:10,566 --> 00:01:12,772
of the known Universe.

19
00:01:12,772 --> 00:01:14,740
That gives you a good picture

20
00:01:14,740 --> 00:01:18,230
of the size of the problem (laughter)

21
00:01:18,230 --> 00:01:20,329
And actually it's a hint at

22
00:01:20,329 --> 00:01:23,036
what I was supposed to become

23
00:01:23,036 --> 00:01:26,011
because I was studying astrophysics

24
00:01:26,011 --> 00:01:30,570
and I switched in college to Computer Science.

25
00:01:30,570 --> 00:01:34,589
My view of the computing world is that

26
00:01:34,589 --> 00:01:38,792
even today we are still using some primitive

27
00:01:38,792 --> 00:01:41,018
tools and techniques.

28
00:01:41,018 --> 00:01:44,653
So we are not very far from these two guys

29
00:01:44,653 --> 00:01:46,357
on the software side.

30
00:01:46,357 --> 00:01:49,283
We are still doing it in a very primitive way

31
00:01:49,283 --> 00:01:51,928
because we keep reinventing the wheels

32
00:01:51,928 --> 00:01:54,513
and constantly are doing the same mistakes

33
00:01:54,513 --> 00:01:56,041
again and again.

34
00:01:56,041 --> 00:01:58,892
So AI will be laughing.

35
00:01:58,902 --> 00:02:02,541
At least I hope. :-) (laughter)

36
00:02:02,541 --> 00:02:08,308
So if we get back a bit more on the topic

37
00:02:08,308 --> 00:02:12,563
there are actually a lot of programming languages

38
00:02:12,563 --> 00:02:14,927
If you look at the Wikipedia list

39
00:02:14,927 --> 00:02:18,596
of programming languages, this is just the A part

40
00:02:18,596 --> 00:02:23,107
and that page is not even exhaustive.

41
00:02:23,107 --> 00:02:24,802
So there are literally thousands

42
00:02:24,802 --> 00:02:27,188
of programming languages.

43
00:02:27,188 --> 00:02:29,588
If you look there you will see some languages

44
00:02:29,588 --> 00:02:32,839
that were created on the Amiga.

45
00:02:32,839 --> 00:02:34,465
The famous "Amiga E"

46
00:02:34,465 --> 00:02:37,288
and AMOS which made by a French guy...

47
00:02:37,288 --> 00:02:42,988
a very bright guy, whose name is FranÃ§ois Lionet.

48
00:02:42,988 --> 00:02:46,500
This Basic was featuring a DSL.

49
00:02:46,500 --> 00:02:50,240
It was a tool I used to have

50
00:02:50,240 --> 00:02:52,899
more than 20 years ago.

51
00:02:52,899 --> 00:02:56,445
The DSL was meant for animations...

52
00:02:56,445 --> 00:03:00,268
...it was compiled to native code.

53
00:03:00,268 --> 00:03:04,439
And the whole interpreter and compiler and IDE

54
00:03:04,439 --> 00:03:10,624
for AMOS was fully written in assembler.

55
00:03:10,624 --> 00:03:15,262
So this guy was quite an inspiration for me.

56
00:03:15,262 --> 00:03:19,448
Despite so many programming languages

57
00:03:19,448 --> 00:03:22,985
and tools we are still searching for a newer,

58
00:03:22,985 --> 00:03:25,197
better solution.

59
00:03:25,197 --> 00:03:28,035
The problems we are facing every day

60
00:03:28,035 --> 00:03:31,225
in the software world are quite known now

61
00:03:31,225 --> 00:03:34,345
but we keep hitting them.

62
00:03:34,345 --> 00:03:37,582
Like exploding complexity... bloatware...

63
00:03:37,582 --> 00:03:40,334
No I don't mean Java, of course. (laughter)

64
00:03:40,334 --> 00:03:42,225
Not thinking about Java. :-P

65
00:03:42,225 --> 00:03:44,769
Slow performance... Black boxes, which can be

66
00:03:44,769 --> 00:03:46,554
closed source software, for example.

67
00:03:46,554 --> 00:03:49,598
Which is often a big problem when trying

68
00:03:49,598 --> 00:03:53,461
to solve bugs that you can't reach.

69
00:03:53,461 --> 00:03:57,872
So instead of spending our time hitting these walls

70
00:03:57,872 --> 00:04:00,348
we should have fun doing programming

71
00:04:00,348 --> 00:04:02,665
because programming is about having fun.

72
00:04:02,665 --> 00:04:05,265
And this is the spirit we should have when

73
00:04:05,265 --> 00:04:07,852
we are facing our computer and working on it.

74
00:04:07,852 --> 00:04:11,400
It's like in those times where programming

75
00:04:11,400 --> 00:04:13,440
was *only* fun.

76
00:04:13,440 --> 00:04:16,441
Since then, since the 80's

77
00:04:16,441 --> 00:04:19,490
a lot of revolutions happened.

78
00:04:19,490 --> 00:04:21,716
And currently we have two -- I think --

79
00:04:21,716 --> 00:04:25,710
very important changes in the computing world.

80
00:04:25,710 --> 00:04:28,281
The first one is augmenting the power

81
00:04:28,281 --> 00:04:31,224
of computers by adding new cores

82
00:04:31,224 --> 00:04:34,934
instead of raising the frequency of the CPUs.

83
00:04:34,934 --> 00:04:39,320
This has deep implications for programming tools.

84
00:04:39,320 --> 00:04:44,062
The other main revolution is that we are all now

85
00:04:44,062 --> 00:04:46,772
switching to mobile devices.

86
00:04:46,772 --> 00:04:49,987
The market is changing very fast.

87
00:04:49,987 --> 00:04:52,947
So the programming tools also need to adapt.

88
00:04:52,947 --> 00:04:56,540
Despite those changes,

89
00:04:56,540 --> 00:04:59,593
we are still using very old tools, in fact.

90
00:04:59,593 --> 00:05:03,677
So I took just the five most popular

91
00:05:03,677 --> 00:05:07,004
programming languages from the Tiobe index...

92
00:05:07,004 --> 00:05:09,111
...the famous index.

93
00:05:09,111 --> 00:05:12,114
Yeah, C is still the main one

94
00:05:12,114 --> 00:05:14,672
and it's been around for almost 40 years now.

95
00:05:14,672 --> 00:05:18,748
That's quite a long time in computing!

96
00:05:18,748 --> 00:05:22,984
And C is absolutely not meant to address

97
00:05:22,984 --> 00:05:25,417
the modern needs for computing.

98
00:05:25,417 --> 00:05:27,973
And if you look at the other ones

99
00:05:27,973 --> 00:05:30,784
that's almost more or less the same thing.

100
00:05:30,784 --> 00:05:33,205
Fortunately for us, some people...

101
00:05:33,205 --> 00:05:36,211
...some very rare people were aware of this

102
00:05:36,211 --> 00:05:41,981
and capable of giving an answer to these issues.

103
00:05:41,981 --> 00:05:45,129
People like Carl (gestures to Carl Sassenrath)

104
00:05:45,129 --> 00:05:47,309
who invented Rebol... fantastic tool.

105
00:05:47,309 --> 00:05:50,383
Probably one of the greatest inventions

106
00:05:50,383 --> 00:05:55,080
in the programming world in the last 20 years.

107
00:05:55,080 --> 00:05:57,875
So Rebol was a good solution, or a very

108
00:05:57,875 --> 00:06:00,598
good solution for a lot of concerns.

109
00:06:00,598 --> 00:06:01,978
*But not all.*

110
00:06:01,978 --> 00:06:05,352
Something I would like to show to Carl...

111
00:06:05,352 --> 00:06:08,556
...maybe he hasn't seen it?

112
00:06:08,556 --> 00:06:12,917
The wonders Rebol was doing, until recently,

113
00:06:12,917 --> 00:06:17,277
was just the Rebol community praising it

114
00:06:17,277 --> 00:06:20,004
and trying to explain to people how Rebol

115
00:06:20,004 --> 00:06:23,947
was a productive tool, and expressive.

116
00:06:23,947 --> 00:06:28,282
But recently a scientific study tried to measure

117
00:06:28,282 --> 00:06:32,133
the expressiveness of programming languages.

118
00:06:32,133 --> 00:06:37,597
So they did it. And Rebol... *surprise*! Is number 3.

119
00:06:37,597 --> 00:06:41,516
In fact: number 1 and number 2 are DSLs.

120
00:06:41,516 --> 00:06:44,526
So guess who's the first one? (laughter)

121
00:06:44,526 --> 00:06:49,040
So that just confirms something we all knew

122
00:06:49,040 --> 00:06:51,141
since the beginning.

123
00:06:51,141 --> 00:06:53,307
Rebol is a very productive tool

124
00:06:53,307 --> 00:06:55,935
and that's now proven. (laughter)

125
00:06:55,935 --> 00:07:00,715
But Red tries to go beyond what Rebol provides.

126
00:07:00,715 --> 00:07:03,002
Mainly in terms of implementation

127
00:07:03,002 --> 00:07:06,519
not in terms of language semantics or syntax.

128
00:07:06,519 --> 00:07:10,458
But more in terms of toolchain, implementations,

129
00:07:10,458 --> 00:07:13,065
and spreading.

130
00:07:13,065 --> 00:07:16,160
So what is Red, really?

131
00:07:16,160 --> 00:07:17,653
Red is what I call

132
00:07:17,653 --> 00:07:19,212
a *Full-Stack Programming Language*

133
00:07:19,212 --> 00:07:22,317
Maybe you've heard about full-stack developers?

134
00:07:22,317 --> 00:07:25,796
So this one is a full-stack programming language.

135
00:07:25,796 --> 00:07:28,995
And probably it's main characteristic

136
00:07:28,995 --> 00:07:31,188
is that it's a true general purpose

137
00:07:31,188 --> 00:07:33,287
programming solution.

138
00:07:33,287 --> 00:07:35,182
There are many languages

139
00:07:35,182 --> 00:07:39,288
that *advertise* as general purpose...

140
00:07:39,288 --> 00:07:43,358
...but they are not as broad as Red can be.

141
00:07:43,358 --> 00:07:47,121
The other great characteristic about Red

142
00:07:47,121 --> 00:07:49,413
is that it's a stand-alone toolchain

143
00:07:49,413 --> 00:07:52,050
so we are not depending on the standard

144
00:07:52,050 --> 00:07:56,488
classic C toolchain, we have our own one.

145
00:07:56,488 --> 00:07:59,648
Another important aspect of Red

146
00:07:59,648 --> 00:08:01,421
is it's about *freedom*.

147
00:08:01,421 --> 00:08:03,695
Since the beginning my motivation for Red

148
00:08:03,695 --> 00:08:07,334
was to get free of any kind of restrictions

149
00:08:07,334 --> 00:08:08,995
or any kind of limits.

150
00:08:08,995 --> 00:08:14,230
I want users of Red to feel the same.

151
00:08:14,230 --> 00:08:18,165
So Red is simple to use, *thanks to Rebol*...

152
00:08:18,165 --> 00:08:23,770
...but Red has no arbitrary restrictions.

153
00:08:23,770 --> 00:08:26,374
We try to address every possible need

154
00:08:26,374 --> 00:08:28,138
and every possible aspect so it

155
00:08:28,138 --> 00:08:33,154
can be deployed, ported to any platform we need.

156
00:08:33,154 --> 00:08:35,799
Also, something very important in programming:

157
00:08:35,799 --> 00:08:39,061
you need to be feeling in control of your tool.

158
00:08:39,061 --> 00:08:42,836
Often you use some tools that can be powerful

159
00:08:42,836 --> 00:08:44,878
but you don't control them, because

160
00:08:44,878 --> 00:08:47,250
you don't understand what's happening inside.

161
00:08:47,250 --> 00:08:48,730
Often because they are black boxes.

162
00:08:48,730 --> 00:08:52,495
Or because they are sitting on a big pile of layers

163
00:08:52,495 --> 00:08:56,225
of software so you can't just understand

164
00:08:56,225 --> 00:08:57,921
what is happening inside.

165
00:08:57,921 --> 00:09:02,394
And an important last thing :-)

166
00:09:02,394 --> 00:09:04,521
is the *Fun*. Yeah, we want the fun back.

167
00:09:04,521 --> 00:09:08,808
Some people that tried to use Red

168
00:09:08,808 --> 00:09:11,465
or Red/System, after compiling and running

169
00:09:11,465 --> 00:09:14,262
their first program successfully

170
00:09:14,262 --> 00:09:16,175
came back to me and said:

171
00:09:16,175 --> 00:09:17,367
"It's great because, it's fun."

172
00:09:17,367 --> 00:09:21,281
"I just tried it, and it worked, and it was great."

173
00:09:21,281 --> 00:09:25,132
People get that feeling -- what I was talking about

174
00:09:25,132 --> 00:09:27,620
That feeling from the 80's.

175
00:09:27,620 --> 00:09:29,347
Where you feel really in control

176
00:09:29,347 --> 00:09:31,121
of your programming tool.

177
00:09:31,121 --> 00:09:34,387
So I'll try to explain what I mean by

178
00:09:34,387 --> 00:09:36,782
"Full-Stack Programming Language" and

179
00:09:36,782 --> 00:09:40,455
"True General-Purpose Programming Language".

180
00:09:40,455 --> 00:09:42,096
So I made this chart:

181
00:09:42,096 --> 00:09:43,414
"Domain Scope of Application"

182
00:09:43,414 --> 00:09:46,570
for a few of the main programming languages.

183
00:09:46,570 --> 00:09:49,393
For example, assembler is drivers

184
00:09:49,393 --> 00:09:52,019
and very low-level code.

185
00:09:52,019 --> 00:09:54,895
You can see that Java is really limited in its

186
00:09:54,895 --> 00:09:58,084
ability to address different abstraction levels.

187
00:09:58,084 --> 00:10:00,607
Ruby is quite wide;

188
00:10:00,607 --> 00:10:02,989
maybe it doesn't go down to the OS?

189
00:10:02,989 --> 00:10:05,598
I don't know if the Ruby interface

190
00:10:05,598 --> 00:10:09,888
for calling OS API is really good or not.

191
00:10:09,888 --> 00:10:13,324
Rebol has quite a wide scope.

192
00:10:13,324 --> 00:10:16,880
Rascal is a very specific programming language.

193
00:10:16,880 --> 00:10:19,540
It's a kind of DSL,

194
00:10:19,540 --> 00:10:23,246
which is meant for writing other DSLs.

195
00:10:23,246 --> 00:10:26,522
So it's standing at the meta-DSL level.

196
00:10:26,522 --> 00:10:30,356
So where is Red on that scale?

197
00:10:30,356 --> 00:10:33,954
Well Red is aiming at addresing all needs

198
00:10:33,954 --> 00:10:37,272
from the bottom to the top.

199
00:10:37,272 --> 00:10:40,596
Because I don't want to have to rely on another tool.

200
00:10:40,596 --> 00:10:43,056
I want the Red programming language

201
00:10:43,056 --> 00:10:45,913
to be able to address all the needs

202
00:10:45,913 --> 00:10:48,272
without relying on something else.

203
00:10:48,272 --> 00:10:51,236
So you will tell me that it's quite impossible

204
00:10:51,236 --> 00:10:53,307
to make a language that addresses

205
00:10:53,307 --> 00:10:56,058
such a wide scope.

206
00:10:56,058 --> 00:10:58,201
And you'll be right.

207
00:10:58,201 --> 00:11:00,771
But Red has a trump card.

208
00:11:00,771 --> 00:11:04,418
Red/System covers the low layers

209
00:11:04,418 --> 00:11:06,604
and Red covers the upper layers.

210
00:11:06,604 --> 00:11:10,037
They are integrated together

211
00:11:10,037 --> 00:11:11,702
and working together.

212
00:11:11,702 --> 00:11:15,114
So Red/System, in fact, is a dialect of Red.

213
00:11:15,114 --> 00:11:17,191
You can use it separately

214
00:11:17,191 --> 00:11:20,112
or directly embedded totally in Red.

215
00:11:20,112 --> 00:11:25,446
So let's have a look at the platforms we support.

216
00:11:25,446 --> 00:11:26,597
First on the desktop,

217
00:11:26,597 --> 00:11:30,755
we support the classic 3 main players.

218
00:11:30,755 --> 00:11:34,424
We also support some additional

219
00:11:34,424 --> 00:11:36,693
operating systems like Syllable.

220
00:11:36,693 --> 00:11:38,829
We would like to support FreeBSD

221
00:11:38,829 --> 00:11:41,350
but we had some low-level issues

222
00:11:41,350 --> 00:11:45,053
and no FreeBSD experts among us

223
00:11:45,053 --> 00:11:48,456
to solve those, so for now it's a bit stalled.

224
00:11:48,456 --> 00:11:52,454
But we could probably get Red ported

225
00:11:52,454 --> 00:11:54,855
on FreeBSD rapidly.

226
00:11:54,855 --> 00:11:57,687
Then we also want to address

227
00:11:57,687 --> 00:12:00,774
the embedded market, starting with Android.

228
00:12:00,774 --> 00:12:02,771
which we already support.

229
00:12:02,771 --> 00:12:04,787
The next one will be iOS.

230
00:12:04,787 --> 00:12:07,905
And we already run on Raspberry Pi

231
00:12:07,905 --> 00:12:10,367
which is becoming quite popular.

232
00:12:10,367 --> 00:12:14,720
I guess Bo will do some demonstrations

233
00:12:14,720 --> 00:12:17,929
maybe tomorrow.

234
00:12:17,929 --> 00:12:22,868
We also have an experimental port on Arduino

235
00:12:22,868 --> 00:12:27,030
We started with AVR 8-bit.

236
00:12:27,030 --> 00:12:30,044
But it's an experiment for now

237
00:12:30,044 --> 00:12:32,895
because other boards are coming

238
00:12:32,895 --> 00:12:36,014
like 32-bit boards or Raspberry Pi.

239
00:12:36,014 --> 00:12:41,790
So 8-bit support may not be the thing to do now.

240
00:12:41,790 --> 00:12:45,320
We also want to support virtual machines.

241
00:12:45,320 --> 00:12:49,753
We want to be able to connect to .NET

242
00:12:49,753 --> 00:12:53,139
to the JVM, and to JavaScript.

243
00:12:53,139 --> 00:12:55,602
There are basically two methods

244
00:12:55,602 --> 00:12:56,467
to achieve this.

245
00:12:56,467 --> 00:13:00,940
We can have a bridge, keeping Red like it is now

246
00:13:00,940 --> 00:13:06,438
and bridging with these virtual machines.

247
00:13:06,438 --> 00:13:08,746
Or we can develop a new backend

248
00:13:08,746 --> 00:13:11,146
for Red and Red/System

249
00:13:11,146 --> 00:13:13,710
to be able to compile directly to the bytecode

250
00:13:13,710 --> 00:13:15,817
of these virtual machines.

251
00:13:15,817 --> 00:13:17,905
So we have those two options.

252
00:13:17,905 --> 00:13:21,645
We started by making some bridges to the JVM.

253
00:13:21,645 --> 00:13:26,405
We'll try to choose each time

254
00:13:26,405 --> 00:13:30,067
the right solution -- the best one for the job.

255
00:13:30,067 --> 00:13:33,188
So right now we are bridging with the JVM.

256
00:13:33,188 --> 00:13:37,997
But we will probably compile for JavaScript directly.

257
00:13:37,997 --> 00:13:41,551
We have asm.js now, so we have

258
00:13:41,551 --> 00:13:45,325
a really interesting platform to support.

259
00:13:45,325 --> 00:13:47,584
I expect Red and Red/System

260
00:13:47,584 --> 00:13:50,755
to run quite fast on that.

261
00:13:50,755 --> 00:13:53,753
More practically, just another view of how it works

262
00:13:53,753 --> 00:13:57,242
So you have Red: one binary.

263
00:13:57,242 --> 00:14:01,118
You download and get all these features.

264
00:14:01,118 --> 00:14:04,756
You can run a Red script directly from memory.

265
00:14:04,756 --> 00:14:08,124
You can compile it to an executable.

266
00:14:08,124 --> 00:14:12,805
You can cross-compile it...

267
00:14:12,805 --> 00:14:15,324
we'll get back to that feature.

268
00:14:15,324 --> 00:14:19,071
You can also directly compile Red/System scripts,

269
00:14:19,071 --> 00:14:22,291
if you don't want to use the Red layer

270
00:14:22,291 --> 00:14:26,063
but you want to code a low-level application.

271
00:14:26,063 --> 00:14:29,955
And you can also now compile shared libraries

272
00:14:29,955 --> 00:14:32,948
that opens the door for spreading Red

273
00:14:32,948 --> 00:14:36,582
by plugging it everywhere we can.

274
00:14:36,582 --> 00:14:39,954
You can also launch Red in a console mode

275
00:14:39,954 --> 00:14:42,206
so we have a Red console.

276
00:14:42,206 --> 00:14:45,499
So cross-compilation... Red is now able to cross-compile

277
00:14:45,499 --> 00:14:49,442
to other systems, from any system to another.

278
00:14:49,442 --> 00:14:52,731
In fact it's able to compile from any platform

279
00:14:52,731 --> 00:14:56,113
where Rebol runs to any other platform.

280
00:14:56,113 --> 00:15:00,808
To achieve that you don't need a HOWTO

281
00:15:00,808 --> 00:15:02,363
You don't need a tutorial.

282
00:15:02,363 --> 00:15:04,788
You don't need to search on the Net for

283
00:15:04,788 --> 00:15:07,182
how to achieve it.

284
00:15:07,182 --> 00:15:10,293
You simply pass a "-t" command and the target ID

285
00:15:10,293 --> 00:15:11,777
and that is all.

286
00:15:11,777 --> 00:15:16,750
A target ID is just an entry in a configuration file

287
00:15:16,750 --> 00:15:21,988
a simple Red dialect, where we just list

288
00:15:21,988 --> 00:15:26,132
some options for the target platform.

289
00:15:26,132 --> 00:15:31,110
So currently we have this list of about 8 targets

290
00:15:31,110 --> 00:15:33,602
So we can cross-compile from any one

291
00:15:33,602 --> 00:15:35,828
to any other, as long as Rebol

292
00:15:35,828 --> 00:15:40,124
runs on the source platform.

293
00:15:40,124 --> 00:15:41,557
So as you can see we are supporting mainly

294
00:15:41,557 --> 00:15:45,594
x86 and ARM based platforms.

295
00:15:45,594 --> 00:15:49,412
To get a bit deeper inside the toolchain

296
00:15:49,412 --> 00:15:51,796
we have several parts.

297
00:15:51,796 --> 00:15:54,506
We have the classical couple: compiler, linker.

298
00:15:54,506 --> 00:16:01,832
So the compiler layer is able to mainly address

299
00:16:01,832 --> 00:16:07,115
those two backends, x86 and ARM.

300
00:16:07,115 --> 00:16:11,919
But we plan to extend it to support ARMv7

301
00:16:11,919 --> 00:16:17,236
"thumb mode" and 64-bit platforms.

302
00:16:17,236 --> 00:16:22,287
We also will add the virtual machine backends.

303
00:16:22,287 --> 00:16:26,207
So JavaScript, JVM bytecode... Dex for Dalvik

304
00:16:26,207 --> 00:16:30,153
as an alternative for JVM on Android platform.

305
00:16:30,153 --> 00:16:34,462
And MSIL stands for the bytecode name

306
00:16:34,462 --> 00:16:37,043
for the .NET platform.

307
00:16:37,043 --> 00:16:39,737
So the Linker is supporting the main file formats.

308
00:16:39,737 --> 00:16:43,532
We will extend it to also support static libraries.

309
00:16:43,532 --> 00:16:46,418
So you'll be able to compile a Red program

310
00:16:46,418 --> 00:16:51,578
as a static library so you can link it later

311
00:16:51,578 --> 00:16:55,233
with another external toolchain, like a C one.

312
00:16:55,233 --> 00:16:59,655
That's an alternative way to spread Red

313
00:16:59,655 --> 00:17:02,448
and to enable people to use Red

314
00:17:02,448 --> 00:17:04,962
in third-party toolchain languages/applications.

315
00:17:04,962 --> 00:17:09,242
And we also go down to the kernel level

316
00:17:09,242 --> 00:17:14,305
and we will provide support for building

317
00:17:14,305 --> 00:17:19,234
kernel drivers, or even full operating systems

318
00:17:19,234 --> 00:17:21,787
directly from Red.

319
00:17:21,787 --> 00:17:24,199
And currently we have experimental

320
00:17:24,199 --> 00:17:27,504
Windows kernel driver support, already working.

321
00:17:27,504 --> 00:17:31,980
If there are kernel driver developers here

322
00:17:31,980 --> 00:17:34,213
you can have fun with it. :-P

323
00:17:34,213 --> 00:17:37,458
Last one: something that doesn't exist

324
00:17:37,458 --> 00:17:40,247
as far as I know, in the classic C toolchain:

325
00:17:40,247 --> 00:17:42,530
we'll have a packager layer

326
00:17:42,530 --> 00:17:46,044
which is not implemented yet, but will be soon.

327
00:17:46,044 --> 00:17:51,589
We'll start with the Android APK backend.

328
00:17:51,589 --> 00:17:54,697
So the point of this layer

329
00:17:54,697 --> 00:17:58,850
is just to take several files and package them

330
00:17:58,850 --> 00:18:03,445
and format them like the target platform expects.

331
00:18:03,445 --> 00:18:06,426
So we'll support Android, we'll support iOS.

332
00:18:06,426 --> 00:18:08,997
But such a packager could also be used

333
00:18:08,997 --> 00:18:13,409
for packaging web applications.

334
00:18:13,409 --> 00:18:17,371
So like Java does for the .WAR format

335
00:18:17,371 --> 00:18:20,196
which has very interesting abilities

336
00:18:20,196 --> 00:18:23,489
like simplifying the deployment of web applications

337
00:18:23,489 --> 00:18:25,276
and being able to version them

338
00:18:25,276 --> 00:18:27,050
or roll back deployment

339
00:18:27,050 --> 00:18:29,342
which are great things to have.

340
00:18:29,342 --> 00:18:31,027
Another aspect of the toolchain

341
00:18:31,027 --> 00:18:32,544
is that currently the toolchain

342
00:18:32,544 --> 00:18:36,774
is bootstrapped in Rebol 2.

343
00:18:36,774 --> 00:18:40,686
We are already running on that for two years.

344
00:18:40,686 --> 00:18:46,907
But the final Red will have a JIT compiler.

345
00:18:46,907 --> 00:18:50,717
To have a JIT compiler we need to go self-hosted.

346
00:18:50,717 --> 00:18:54,347
So we need to have Red written in Red.

347
00:18:54,347 --> 00:18:58,587
That's the only way to get a proper JIT compiler.

348
00:18:58,587 --> 00:19:03,543
So we'll most probably work on that next year.

349
00:19:03,543 --> 00:19:07,550
I have a few slides about the Red language itself.

350
00:19:07,550 --> 00:19:10,796
But I won't go into too many details

351
00:19:10,796 --> 00:19:13,394
because it will take too much time.

352
00:19:13,394 --> 00:19:18,018
The first thing to understand about Red language

353
00:19:18,018 --> 00:19:21,098
is that it's very close to Rebol.

354
00:19:21,098 --> 00:19:26,585
You have some of the main Rebol characteristics

355
00:19:26,585 --> 00:19:31,588
like definitional scoping and dynamic binding.

356
00:19:31,588 --> 00:19:37,178
You also have the ability to program in Red

357
00:19:37,178 --> 00:19:40,106
using whatever paradigm you want.

358
00:19:40,106 --> 00:19:43,031
So *"paradigm-neutral"* is an expression

359
00:19:43,031 --> 00:19:46,673
from Gabriele (Santilli) and I like it very much

360
00:19:46,673 --> 00:19:50,013
because it expresses really well this ability

361
00:19:50,013 --> 00:19:53,878
to not be bound by a specific paradigm.

362
00:19:55,318 --> 00:19:59,298
A difference between Red and Rebol

363
00:19:59,298 --> 00:20:05,376
is that in Red you can optionally type local variables

364
00:20:05,376 --> 00:20:09,756
and you can also type the return value

365
00:20:09,756 --> 00:20:12,147
of functions.

366
00:20:12,147 --> 00:20:17,048
So in Rebol, it doesn't have much meaning

367
00:20:17,048 --> 00:20:25,102
because it's an interpreter, and it has no value.

368
00:20:25,102 --> 00:20:27,874
But for a compiler, it has great value.

369
00:20:27,874 --> 00:20:33,604
Because annotating those types in the function

370
00:20:33,604 --> 00:20:37,791
allows the compiler to generate

371
00:20:37,791 --> 00:20:43,616
much more specialized, faster, and efficient code

372
00:20:43,616 --> 00:20:46,818
than without the annotations.

373
00:20:47,728 --> 00:20:53,186
Red is "optionally typed". So you can type it or not.

374
00:20:53,186 --> 00:20:56,989
It depends on your needs, or the way you program.

375
00:20:56,989 --> 00:20:59,333
So you can do it in the Rebol way

376
00:20:59,333 --> 00:21:01,619
which will be very flexible.

377
00:21:01,619 --> 00:21:06,168
But you will end up with slower performance.

378
00:21:06,168 --> 00:21:08,549
Or you can do it the static way

379
00:21:08,549 --> 00:21:10,581
where you type everything

380
00:21:10,581 --> 00:21:13,702
and the compiler will be able to do more type-checking

381
00:21:13,702 --> 00:21:16,969
so you will get some warnings or some errors

382
00:21:16,969 --> 00:21:21,230
at compile-time instead of getting them at run-time.

383
00:21:21,230 --> 00:21:28,353
Also, if you are not using the type annotations

384
00:21:28,353 --> 00:21:31,687
the compiler will be able in some cases

385
00:21:31,687 --> 00:21:34,141
to do some type inference.

386
00:21:34,141 --> 00:21:36,654
So it will be able to guess the types for you.

387
00:21:36,654 --> 00:21:41,093
But as Red, like Rebol, is a very dynamic language

388
00:21:41,093 --> 00:21:48,734
the extent to which the inference engine

389
00:21:48,734 --> 00:21:53,581
can guess those types is quite limited.

390
00:21:53,581 --> 00:21:56,756
So, it will be a little help, but not a big one.

391
00:21:56,756 --> 00:22:01,167
We of course have Unicode support.

392
00:22:01,167 --> 00:22:04,623
Red source code is UTF-8.

393
00:22:04,623 --> 00:22:09,567
We'll provide some external codecs for other encodings.

394
00:22:09,567 --> 00:22:16,728
Internally, basically, Red stores and manages

395
00:22:16,728 --> 00:22:20,036
Unicode strings like Python does

396
00:22:20,036 --> 00:22:22,719
in the latest versions.

397
00:22:22,719 --> 00:22:29,671
So the internal storage is fixed size.

398
00:22:29,671 --> 00:22:35,382
But it can take from 1 byte to up to 4 bytes

399
00:22:35,382 --> 00:22:37,921
per codepoint.

400
00:22:37,921 --> 00:22:40,144
And the system will automatically adapt

401
00:22:40,144 --> 00:22:43,224
and adjust the size according to the input

402
00:22:43,224 --> 00:22:48,908
and the modifications you are making on the string.

403
00:22:48,908 --> 00:22:54,977
Another part that's very important in Red

404
00:22:54,977 --> 00:22:57,640
is the concurrency support.

405
00:22:57,640 --> 00:23:00,108
But currently it's not implemented

406
00:23:00,108 --> 00:23:04,207
so I won't go in details about that.

407
00:23:04,207 --> 00:23:09,102
We want to support two main things:

408
00:23:09,102 --> 00:23:11,330
we want to support task parallelism

409
00:23:11,330 --> 00:23:15,331
so you can execute several threads of code

410
00:23:15,331 --> 00:23:18,367
in parallel using other multiple cores.

411
00:23:18,367 --> 00:23:21,891
We'll probably use the Actor abstractions.

412
00:23:21,891 --> 00:23:26,693
But there are other abstractions

413
00:23:26,693 --> 00:23:31,042
that since the beginning of the Red project

414
00:23:31,042 --> 00:23:34,926
are getting a lot of traction. Like Go routines,

415
00:23:34,926 --> 00:23:38,981
which are becoming a big selling point

416
00:23:38,981 --> 00:23:40,645
for the Go language.

417
00:23:40,645 --> 00:23:43,082
So that's something we should consider

418
00:23:43,082 --> 00:23:45,725
also for Red, maybe...

419
00:23:45,725 --> 00:23:48,651
in addition or as a replacement for actors

420
00:23:48,651 --> 00:23:50,974
and other kinds of abstractions.

421
00:23:50,974 --> 00:23:54,765
So when we get to the point of implementing

422
00:23:54,765 --> 00:23:57,311
the concurrency support we need to revise

423
00:23:57,311 --> 00:23:59,900
all the design choices and see

424
00:23:59,900 --> 00:24:03,665
if we can update them by copying

425
00:24:03,665 --> 00:24:06,840
some other successful strategies.

426
00:24:06,840 --> 00:24:09,047
We also want to have some level of

427
00:24:09,047 --> 00:24:13,712
data parallelism using either SIMD

428
00:24:13,712 --> 00:24:16,582
or multicore processing.

429
00:24:16,582 --> 00:24:19,851
So basically that will be using the ability

430
00:24:19,851 --> 00:24:25,917
to parallelize processing of Red series.

431
00:24:25,917 --> 00:24:30,758
We would also like to address something

432
00:24:30,758 --> 00:24:33,476
that Rebol currently doesn't really address

433
00:24:33,476 --> 00:24:36,231
which is: how do you make a dialect?

434
00:24:36,231 --> 00:24:38,956
Or how do you make a DSL?

435
00:24:38,956 --> 00:24:41,438
Rebol is great for that --

436
00:24:41,438 --> 00:24:44,368
it's probably one of the best tools for doing that

437
00:24:44,368 --> 00:24:45,658
because it has PARSE and because

438
00:24:45,658 --> 00:24:48,084
it has some interesting qualities

439
00:24:48,084 --> 00:24:50,101
that make it a good choice for that.

440
00:24:50,101 --> 00:24:54,911
Anyway building a DSL or building a dialect

441
00:24:54,911 --> 00:24:57,186
is not something easy.

442
00:24:57,186 --> 00:24:59,774
Because you need to design it first.

443
00:24:59,774 --> 00:25:01,425
That's already a lot of work.

444
00:25:01,425 --> 00:25:03,427
And then you need to implement it.

445
00:25:03,427 --> 00:25:07,113
And implementing a DSL or a dialect

446
00:25:07,113 --> 00:25:11,151
is implementing an interpreter or a compiler.

447
00:25:11,151 --> 00:25:17,524
For that you are almost left alone with the code.

448
00:25:17,524 --> 00:25:20,462
So you don't have really a framework

449
00:25:20,462 --> 00:25:22,134
for doing that.

450
00:25:22,134 --> 00:25:25,585
And it's possible to leverage the qualities

451
00:25:25,585 --> 00:25:27,439
of the Rebol language in Red

452
00:25:27,439 --> 00:25:29,507
or maybe even in Rebol

453
00:25:29,507 --> 00:25:32,431
to make a kind of meta-DSL

454
00:25:32,431 --> 00:25:38,218
that will allow you to be much more productive

455
00:25:38,218 --> 00:25:40,920
and give you a framework

456
00:25:40,920 --> 00:25:44,260
for building new dialects and new DSLs.

457
00:25:44,260 --> 00:25:47,156
Basically it will be something like

458
00:25:47,156 --> 00:25:50,105
a higher-level version of PARSE.

459
00:25:50,105 --> 00:25:52,557
You can think about it, for example,

460
00:25:52,557 --> 00:25:59,457
like having PARSE with an event loop

461
00:25:59,457 --> 00:26:03,732
and the event loop will be hidden.

462
00:26:03,732 --> 00:26:07,914
Something like Visual Basic does.

463
00:26:07,914 --> 00:26:11,544
And you will just implement events

464
00:26:11,544 --> 00:26:17,351
to create your DSL as an interpreter or compiler.

465
00:26:17,351 --> 00:26:26,170
So what does the Red compiler do?

466
00:26:26,170 --> 00:26:30,786
The Red compiler converts Red code

467
00:26:30,786 --> 00:26:34,944
into Red/System which is the lower-level layer.

468
00:26:34,944 --> 00:26:40,093
I just wanted to show you what it looks like.

469
00:26:40,093 --> 00:26:45,535
So if we take a very simple Red expression

470
00:26:45,535 --> 00:26:48,493
the Red compiler parses it

471
00:26:48,493 --> 00:26:53,884
and uses a stack abstraction to place the arguments

472
00:26:53,884 --> 00:26:58,480
In fact it uses two stacks: one for calls

473
00:26:58,480 --> 00:27:01,819
and one for arguments.

474
00:27:01,819 --> 00:27:05,361
And then the emitter will produce Red/System code

475
00:27:05,361 --> 00:27:08,363
based on that.

476
00:27:08,363 --> 00:27:10,782
So what you see on the right side

477
00:27:10,782 --> 00:27:14,350
is the Red/System output for that expression

478
00:27:14,350 --> 00:27:18,061
calling the Red runtime API.

479
00:27:22,651 --> 00:27:28,334
Another singular aspect of the Red compiler

480
00:27:28,334 --> 00:27:29,406
and the Red language

481
00:27:29,406 --> 00:27:34,169
is that it combines several kinds of approaches

482
00:27:34,169 --> 00:27:37,846
which is something quite unique, I think.

483
00:27:37,846 --> 00:27:41,156
So basically you have a static compiler.

484
00:27:41,156 --> 00:27:44,538
That static compiler will generate code

485
00:27:44,538 --> 00:27:46,584
with an interpreter inside, and tomorrow

486
00:27:46,584 --> 00:27:51,606
a JIT-compiler embedded inside your executable.

487
00:27:51,606 --> 00:27:58,368
All these three parts will be able to work together

488
00:27:58,368 --> 00:28:02,334
in a very collaborative way.

489
00:28:02,334 --> 00:28:05,191
So for example, the compiled code

490
00:28:05,191 --> 00:28:08,428
can call the internal interpreter

491
00:28:08,428 --> 00:28:12,551
which itself can call back into the compiled code.

492
00:28:12,551 --> 00:28:16,189
Same thing for the JIT compiler.

493
00:28:16,189 --> 00:28:19,973
It's a bit abstract, but I can show you at the end

494
00:28:19,973 --> 00:28:21,707
of the presentation a slide

495
00:28:21,707 --> 00:28:23,904
with a practical case for such an approach.

496
00:28:23,904 --> 00:28:28,901
In fact, such an approach is a very powerful tool

497
00:28:28,901 --> 00:28:35,136
to solve very complex semantic cases.

498
00:28:35,136 --> 00:28:39,575
For example, compiling symbolic code,

499
00:28:39,575 --> 00:28:42,229
which is something quite difficult to achieve.

500
00:28:42,229 --> 00:28:43,740
But if you combine different approaches

501
00:28:43,740 --> 00:28:49,758
you can find a very efficient solution.

502
00:28:49,758 --> 00:28:54,407
So this is just a very simple example

503
00:28:54,407 --> 00:29:00,583
of how Red code looks.

504
00:29:00,583 --> 00:29:03,399
You have the same principle like in Rebol

505
00:29:03,399 --> 00:29:08,492
so you have a marker which is [Red]

506
00:29:08,492 --> 00:29:13,355
followed by a block that constitutes a header

507
00:29:13,355 --> 00:29:17,254
and your code goes after that.

508
00:29:17,254 --> 00:29:19,921
Hello world is just [print "Hello World"]

509
00:29:19,921 --> 00:29:22,312
like in Rebol, and the rest of the code

510
00:29:22,312 --> 00:29:26,336
probably looks very much like Rebol

511
00:29:26,336 --> 00:29:32,270
except maybe for the [return: [type!]]

512
00:29:32,270 --> 00:29:36,908
which is optional, but it's the kind of

513
00:29:36,908 --> 00:29:40,409
optional typing I was talking about just before.

514
00:29:40,409 --> 00:29:43,389
So you have an example there.

515
00:29:43,389 --> 00:29:48,196
It's not mandatory to put it, but if you put it

516
00:29:48,196 --> 00:29:54,758
the compiler will generate better, faster code.

517
00:29:54,758 --> 00:29:59,006
So just a bit more detailed view

518
00:29:59,006 --> 00:30:02,905
of the internals of Red, and the different parts

519
00:30:02,905 --> 00:30:05,640
so you get a better picture of how

520
00:30:05,640 --> 00:30:09,472
all those elements are related.

521
00:30:09,472 --> 00:30:13,971
So if we start from the guy on the right

522
00:30:13,971 --> 00:30:17,047
we have a command-line front-end script

523
00:30:17,047 --> 00:30:19,852
which is written currently in Rebol2

524
00:30:19,852 --> 00:30:25,527
and behind it we have the two stacks

525
00:30:25,527 --> 00:30:28,351
for the two compilers. One for Red, which is

526
00:30:28,351 --> 00:30:32,604
shorter because it just emits code for Red/System.

527
00:30:32,604 --> 00:30:34,311
And one for Red/System

528
00:30:34,311 --> 00:30:36,720
which goes down to the packager

529
00:30:36,720 --> 00:30:41,424
so it can emit and produce binary files.

530
00:30:41,424 --> 00:30:47,027
All that is the toolchain written in Rebol 2.

531
00:30:47,027 --> 00:30:52,304
On the left side, you have the Red runtime.

532
00:30:52,304 --> 00:30:55,586
Which is quite a big piece of code,

533
00:30:55,586 --> 00:30:59,651
actually probably bigger than the other side.

534
00:30:59,651 --> 00:31:02,964
And which is written in Red/System.

535
00:31:02,964 --> 00:31:06,914
So you'll find all the real power on that side

536
00:31:06,914 --> 00:31:08,649
for example, all the datatypes,

537
00:31:08,649 --> 00:31:12,104
all the natives, the mezzanine code,

538
00:31:12,104 --> 00:31:16,600
the interpreter, the bridges -- like the Java one

539
00:31:16,600 --> 00:31:19,025
which is already available.

540
00:31:19,025 --> 00:31:23,058
The memory manager and the low-level interfaces

541
00:31:23,058 --> 00:31:26,485
to the underlying pieces.

542
00:31:26,485 --> 00:31:28,829
So for example you have the direct access

543
00:31:28,829 --> 00:31:31,993
to the OS API but also to the kernel.

544
00:31:31,993 --> 00:31:34,001
On Linux you can do syscalls directly.

545
00:31:34,001 --> 00:31:38,340
And if necessary you can go even down

546
00:31:38,340 --> 00:31:41,869
to the hardware and call very low-level features.

547
00:31:44,599 --> 00:31:46,625
Maybe I just missed the Red Console also

548
00:31:46,625 --> 00:31:49,985
which is also written in Red

549
00:31:49,985 --> 00:31:52,946
and Red/System for the low-level parts.

550
00:31:53,816 --> 00:31:57,120
About Red/System... I have a small presentation

551
00:31:57,120 --> 00:32:01,142
tomorrow specifically on Red/System, because

552
00:32:01,142 --> 00:32:06,082
it's kind of a new thing in Red compared to Rebol.

553
00:32:06,082 --> 00:32:08,541
So I have just a slide about Red/System

554
00:32:08,541 --> 00:32:10,120
to give you just an overview.

555
00:32:10,120 --> 00:32:16,748
So basically it's just a kind of C-level language

556
00:32:16,748 --> 00:32:20,078
but with a Red syntax.

557
00:32:20,078 --> 00:32:22,760
So it often feels like coding in Red

558
00:32:22,760 --> 00:32:29,827
but with very low-level datatypes and actions.

559
00:32:29,827 --> 00:32:32,630
So it's statically compiled.

560
00:32:32,630 --> 00:32:35,956
It's currently not optimized at all. :-)

561
00:32:35,956 --> 00:32:40,988
But it's only 4x slower than optimized C

562
00:32:40,988 --> 00:32:43,849
compiled with "-O2".

563
00:32:43,849 --> 00:32:47,674
So it's quite good, actually it's very good.

564
00:32:47,674 --> 00:32:51,224
Because once we add the optimization layers

565
00:32:51,224 --> 00:32:53,398
we'll be very, very close to C.

566
00:32:53,398 --> 00:32:57,362
We probably won't beat it, but that's not the goal.

567
00:32:57,362 --> 00:33:00,014
But we'll be very, very close.

568
00:33:00,014 --> 00:33:05,041
So Red/System will be a really viable alternative to C.

569
00:33:05,041 --> 00:33:09,334
And it already does wonders in some

570
00:33:09,334 --> 00:33:11,936
image processing for example

571
00:33:11,936 --> 00:33:15,680
that Bo (Lechnowsky) will show you tomorrow.

572
00:33:15,680 --> 00:33:17,968
Something that the C language doesn't have

573
00:33:17,968 --> 00:33:22,310
or most very low-level languages don't have:

574
00:33:22,310 --> 00:33:24,792
Red/System has namespaces,

575
00:33:24,792 --> 00:33:27,024
which are something like contexts in Rebol

576
00:33:27,024 --> 00:33:33,586
but very static, so we are using the CONTEXT keyword

577
00:33:33,586 --> 00:33:35,909
to declare them in Red/System also.

578
00:33:35,909 --> 00:33:38,936
And you can also use the WITH keyword

579
00:33:38,936 --> 00:33:43,428
to put some part of your code inside a context

580
00:33:43,428 --> 00:33:47,121
something like declarations in other languages.

581
00:33:47,121 --> 00:33:52,155
We have a very limited type system in Red/System

582
00:33:52,155 --> 00:34:00,763
We have nine types.

583
00:34:00,763 --> 00:34:05,467
So basically the same datatypes as C.

584
00:34:05,467 --> 00:34:11,372
The function datatype isn't a fully first-class datatype

585
00:34:11,372 --> 00:34:16,155
I have hesitated a lot about that, because...

586
00:34:16,155 --> 00:34:19,723
if I make it a fully first-class datatype

587
00:34:19,723 --> 00:34:22,571
People will start asking for me

588
00:34:22,571 --> 00:34:24,925
to make Red/System a functional language.

589
00:34:24,925 --> 00:34:27,986
Which is possible but it's not the goal.

590
00:34:27,986 --> 00:34:32,540
It doesn't serve any purpose, so I'm quite reluctant

591
00:34:32,540 --> 00:34:37,835
to add new features on that datatype.

592
00:34:37,835 --> 00:34:40,324
We have type inference,

593
00:34:40,324 --> 00:34:42,395
so you don't have to specify the data type

594
00:34:42,395 --> 00:34:45,235
for local variables, the compiler will guess it.

595
00:34:45,235 --> 00:34:48,666
We also have a limited type-casting

596
00:34:48,666 --> 00:34:52,473
between compatible data types.

597
00:34:52,473 --> 00:34:56,548
And we have something C doesn't have

598
00:34:56,548 --> 00:35:04,017
but C++ has, which is some level of reflection.

599
00:35:04,017 --> 00:35:07,445
So you can declare some function in Red/System

600
00:35:07,445 --> 00:35:12,157
with a variable number of arguments

601
00:35:12,157 --> 00:35:14,311
you can put brackets around them

602
00:35:14,311 --> 00:35:16,341
and inside the body of that function

603
00:35:16,341 --> 00:35:19,854
you can walk through that list of arguments

604
00:35:19,854 --> 00:35:23,665
and you can query the type of each argument.

605
00:35:23,665 --> 00:35:26,778
So that's quite a powerful feature,

606
00:35:26,778 --> 00:35:32,499
and actually Kaj de Vos used it to build

607
00:35:32,499 --> 00:35:36,773
a VID-like dialect in Red/System

608
00:35:36,773 --> 00:35:38,853
which is quite a feat because

609
00:35:38,853 --> 00:35:42,243
we don't have symbols in Red/System :-)

610
00:35:42,243 --> 00:35:47,656
So it looks like VID but it's using that feature

611
00:35:47,656 --> 00:35:50,854
to run it, and it's really great.

612
00:35:50,854 --> 00:35:55,630
We also have a preprocessor in Red/System

613
00:35:55,630 --> 00:36:01,262
but I would like to drop it in the next major release

614
00:36:01,262 --> 00:36:06,590
because we have more problems with that

615
00:36:06,590 --> 00:36:11,779
than we have advantages.

616
00:36:11,779 --> 00:36:13,727
So we'll keep a few of them

617
00:36:13,727 --> 00:36:16,774
but we need to rethink it and redesign it.

618
00:36:16,774 --> 00:36:20,186
The #define is a very powerful option

619
00:36:20,186 --> 00:36:22,128
because it gives you almost the same power

620
00:36:22,128 --> 00:36:27,392
as C macros, so you can even use parameters.

621
00:36:27,392 --> 00:36:34,001
We also want to have some low-level CPU support

622
00:36:34,001 --> 00:36:39,385
currently we have access to some CPU registers

623
00:36:39,385 --> 00:36:41,747
in a cross-platform way.

624
00:36:41,747 --> 00:36:43,617
We have access to the stack --

625
00:36:43,617 --> 00:36:46,743
you can manipulate the native stack

626
00:36:46,743 --> 00:36:49,724
at the Red/System level in a cross-platform way.

627
00:36:49,724 --> 00:36:55,232
And we'll add support for interruption I/Os

628
00:36:55,232 --> 00:37:02,004
and other very basic CPU features.

629
00:37:02,004 --> 00:37:07,289
Maybe we'll add some inline assembler support

630
00:37:07,289 --> 00:37:10,224
but it's not currently a big need.

631
00:37:10,224 --> 00:37:13,926
A few metrics about the Red project.

632
00:37:13,926 --> 00:37:18,596
So it's BSD, for most of the codebase.

633
00:37:18,596 --> 00:37:22,560
And the runtime parts of Red are "BSL"

634
00:37:22,560 --> 00:37:25,945
which is the "Boost Software License"

635
00:37:25,945 --> 00:37:32,015
which is even more liberal than BSD.

636
00:37:32,015 --> 00:37:34,999
So you have even less restriction than BSD.

637
00:37:34,999 --> 00:37:37,856
We are on GitHub since the beginning

638
00:37:37,856 --> 00:37:43,033
we have 9 committers... I think that's wrong

639
00:37:43,033 --> 00:37:46,604
it's 11 committers now.

640
00:37:46,604 --> 00:37:50,335
We have more than 2,000 commits

641
00:37:50,335 --> 00:37:52,867
without counting merge commits.

642
00:37:52,867 --> 00:37:58,035
We have about 500 tickets in the bug tracker

643
00:37:58,035 --> 00:38:00,490
but they are almost all closed

644
00:38:00,490 --> 00:38:03,576
we try to get them closed as fast as possible

645
00:38:03,576 --> 00:38:05,852
to avoid piling them up.

646
00:38:05,852 --> 00:38:07,516
Because once they pile up,

647
00:38:07,516 --> 00:38:10,788
you almost never get them processed.

648
00:38:10,788 --> 00:38:14,469
So we really need to keep that very, very low.

649
00:38:14,469 --> 00:38:16,696
We have a lot of unit tests

650
00:38:16,696 --> 00:38:19,569
which are built by Peter Wood

651
00:38:19,569 --> 00:38:23,180
who has done great work on that.

652
00:38:23,180 --> 00:38:25,361
It's very, very helpful.

653
00:38:25,361 --> 00:38:27,897
And here you have a few metrics

654
00:38:27,897 --> 00:38:30,019
about the size of the source code

655
00:38:30,019 --> 00:38:32,026
for the Red and Red/System parts.

656
00:38:32,026 --> 00:38:34,073
For the compiler, for the linker.

657
00:38:34,073 --> 00:38:35,923
So you can see for yourself

658
00:38:35,923 --> 00:38:37,897
that's a really small codebase.

659
00:38:37,897 --> 00:38:41,619
So you can achieve a lot, thanks to Rebol :-)

660
00:38:41,619 --> 00:38:45,444
you can achieve a lot with a small codebase

661
00:38:45,444 --> 00:38:47,680
and a few lines of code.

662
00:38:47,680 --> 00:38:50,946
You can compare that to other toolchains

663
00:38:50,946 --> 00:38:55,006
and you'll often see one or two

664
00:38:55,006 --> 00:38:57,700
orders of magnitude of difference.

665
00:38:57,700 --> 00:38:59,251
Of course they are probably covering

666
00:38:59,251 --> 00:39:01,428
more ground than we do.

667
00:39:01,428 --> 00:39:06,544
But with such a small codebase

668
00:39:06,544 --> 00:39:09,376
we are already covering a lot of ground.

669
00:39:09,376 --> 00:39:14,352
So we still have a lot of work

670
00:39:14,352 --> 00:39:18,824
It's still under heavy construction.

671
00:39:18,824 --> 00:39:23,389
So we have some big core parts missing, still.

672
00:39:23,389 --> 00:39:30,653
We need object support, which is not yet there.

673
00:39:30,653 --> 00:39:34,083
We don't have proper error handling yet

674
00:39:34,083 --> 00:39:36,009
because we need OBJECT! for that.

675
00:39:36,009 --> 00:39:40,244
We lack type checking for arguments

676
00:39:40,244 --> 00:39:42,915
in some parts of the compiler.

677
00:39:42,915 --> 00:39:45,487
We don't have the I/O yet, but...

678
00:39:45,487 --> 00:39:50,941
of course objects and I/O are very high on the list

679
00:39:50,941 --> 00:39:54,697
They probably will be implemented this summer.

680
00:39:54,697 --> 00:39:59,696
We want some level of concurrency support

681
00:39:59,696 --> 00:40:05,334
in the 1.0, and we naturally also want

682
00:40:05,334 --> 00:40:09,829
a modular compilation and module system.

683
00:40:09,829 --> 00:40:14,260
We will probably provide a very minimal Red IDE

684
00:40:14,260 --> 00:40:18,032
which will probably just be a code editor

685
00:40:18,032 --> 00:40:23,468
plus a debugger... and we will work

686
00:40:23,468 --> 00:40:27,570
to extend that in future versions.

687
00:40:27,570 --> 00:40:31,050
We also want full documentation

688
00:40:31,050 --> 00:40:37,597
so that's a big showstopper to release a 1.0

689
00:40:37,597 --> 00:40:41,836
so we have a lot of work to write that documentation

690
00:40:41,836 --> 00:40:43,650
and to write tutorials.

691
00:40:43,650 --> 00:40:46,529
And of course, we need to have a new website

692
00:40:46,529 --> 00:40:49,753
for the version 1.0 launch.

693
00:40:51,613 --> 00:40:54,761
But that's not all... :-)

694
00:40:54,761 --> 00:40:57,310
that's not the real Red.

695
00:40:57,310 --> 00:41:00,523
The real Red will be the 2.0.

696
00:41:00,523 --> 00:41:05,640
And we have a pretty good cast for that (laughter)

697
00:41:05,640 --> 00:41:07,538
So what is "The Real Red"?

698
00:41:07,538 --> 00:41:11,329
In fact, what I've presented so far

699
00:41:11,329 --> 00:41:13,583
is a kind of scaffolding.

700
00:41:13,583 --> 00:41:15,570
Because the real Red is this one.

701
00:41:15,570 --> 00:41:23,308
The real Red will be basically a JIT compiler

702
00:41:23,308 --> 00:41:27,206
that will be able to work as a static compiler too.

703
00:41:27,206 --> 00:41:29,613
The whole internal architecture

704
00:41:29,613 --> 00:41:32,929
will be totally different than the current one

705
00:41:32,929 --> 00:41:35,846
implemented in the bootstrapped version.

706
00:41:35,846 --> 00:41:39,254
So it will be plugin-oriented

707
00:41:39,254 --> 00:41:40,910
so basically the compiler and the toolchain

708
00:41:40,910 --> 00:41:44,718
will be an empty shell -- a framework --

709
00:41:44,718 --> 00:41:49,830
where you will be able to plug in some modules

710
00:41:49,830 --> 00:41:54,223
to add features at every stage of the compilation.

711
00:41:54,223 --> 00:41:57,606
From the parsing to the generation of the files.

712
00:41:57,606 --> 00:42:00,981
You will have an API to work with.

713
00:42:00,981 --> 00:42:03,679
So I will provide the framework

714
00:42:03,679 --> 00:42:07,304
and the minimal modules to make it work

715
00:42:07,304 --> 00:42:10,946
to have the same level of features as the 1.0.

716
00:42:10,946 --> 00:42:15,920
And such an API will be of course documented

717
00:42:15,920 --> 00:42:18,986
so anyone will be able to modify

718
00:42:18,986 --> 00:42:22,012
and add new features to the compiler

719
00:42:22,012 --> 00:42:25,657
in a very isolated way, and very structured way.

720
00:42:25,657 --> 00:42:29,935
Such an API could also be called at runtime.

721
00:42:29,935 --> 00:42:34,584
So I can let you imagine the options and possibilities

722
00:42:34,584 --> 00:42:37,270
with modifying the compiler itself and the toolchain

723
00:42:37,270 --> 00:42:38,819
at runtime.

724
00:42:38,819 --> 00:42:40,186
So it's possible at runtime

725
00:42:40,186 --> 00:42:43,657
to change the language itself or add new features.

726
00:42:43,657 --> 00:42:47,107
It may sound totally crazy

727
00:42:47,107 --> 00:42:48,494
but it's something other languages

728
00:42:48,494 --> 00:42:53,525
which are growing right now

729
00:42:53,525 --> 00:42:56,184
are doing... for example, the Scala language

730
00:42:56,184 --> 00:42:57,921
is doing exactly that.

731
00:42:57,921 --> 00:43:00,094
And some people from the Scala community

732
00:43:00,094 --> 00:43:04,242
are using this kind of feature to do wonders in Scala

733
00:43:04,242 --> 00:43:07,042
For example, one very smart guy

734
00:43:07,042 --> 00:43:13,634
used this API to add parallel support to for loops

735
00:43:13,634 --> 00:43:18,648
by using the GPGPU for parallelizing that

736
00:43:18,648 --> 00:43:23,715
using OpenCL as a low-level layer.

737
00:43:23,715 --> 00:43:27,094
So that's a very powerful feature

738
00:43:27,094 --> 00:43:31,124
and also it makes the compiler architecture

739
00:43:31,124 --> 00:43:37,405
much more solid and allows people to contribute

740
00:43:37,405 --> 00:43:39,391
in a much easier way

741
00:43:39,391 --> 00:43:42,666
and a much more structured way.

742
00:43:42,666 --> 00:43:45,410
So the implication is that the current codebase

743
00:43:45,410 --> 00:43:50,145
of the compiler... so in the Red internal diagram

744
00:43:50,145 --> 00:43:53,929
it was the right side of the blocks...

745
00:43:53,929 --> 00:43:56,942
The current codebase in Rebol 2

746
00:43:56,942 --> 00:44:00,594
is kind of disposable code.

747
00:44:00,594 --> 00:44:04,283
So since the beginning, I wrote it very fast

748
00:44:04,283 --> 00:44:08,540
thinking that I will dump it quickly

749
00:44:08,540 --> 00:44:10,412
in about a year,

750
00:44:10,412 --> 00:44:14,035
and be able to recode it in Red rapidly.

751
00:44:14,035 --> 00:44:18,069
But we changed a lot of things in the project

752
00:44:18,069 --> 00:44:22,374
we adjusted to the evolving environment

753
00:44:22,374 --> 00:44:25,218
so we are not yet there.

754
00:44:25,218 --> 00:44:29,434
So we will first go 1.0 in the bootstrapped version

755
00:44:29,434 --> 00:44:32,590
and the 2.0 will be the self-hosted version

756
00:44:32,590 --> 00:44:35,173
with the toolchain recoded in Red.

757
00:44:35,173 --> 00:44:41,975
The whole Red runtime part will stay the same

758
00:44:41,975 --> 00:44:43,714
because it's coded in Red/System

759
00:44:43,714 --> 00:44:47,340
so it will survive, and that's a very big codebase.

760
00:44:47,340 --> 00:44:50,087
So the only part that will be recoded

761
00:44:50,087 --> 00:44:53,342
will be the Rebol 2 codebase, which are

762
00:44:53,342 --> 00:44:56,511
basically the Red and Red/System compilers

763
00:44:56,511 --> 00:44:59,654
Just a few words about the project organization:

764
00:44:59,654 --> 00:45:05,659
we have two collaborators on GitHub

765
00:45:05,659 --> 00:45:10,028
which means there's one admin and two other people

766
00:45:10,028 --> 00:45:15,747
who have admin rights. So if I get hit by a bus

767
00:45:15,747 --> 00:45:21,832
these two guys could take over the source code

768
00:45:21,832 --> 00:45:26,973
in the Red repository and manage it.

769
00:45:26,973 --> 00:45:30,940
We have about 11 contributors to the codebase

770
00:45:30,940 --> 00:45:33,673
since the beginning. We have a mailing list.

771
00:45:33,673 --> 00:45:37,359
We have a Facebook page, an IRC channel

772
00:45:37,359 --> 00:45:42,087
with a nice IRC bot from Andreas

773
00:45:42,087 --> 00:45:44,471
for reporting commits.

774
00:45:44,471 --> 00:45:46,792
And of course we are seeking other people

775
00:45:46,792 --> 00:45:49,389
who are interested in contributing

776
00:45:49,389 --> 00:45:52,707
and participating in every way

777
00:45:52,707 --> 00:45:54,940
because it's quite a big project...

778
00:45:54,940 --> 00:45:58,775
and we need a lot of helping hands.

779
00:46:00,945 --> 00:46:03,564
Last but not least :-)

780
00:46:03,564 --> 00:46:09,450
I've invested in this project... since I've started

781
00:46:09,450 --> 00:46:12,146
about 2 years and a half ago...

782
00:46:12,146 --> 00:46:16,020
every last cent of savings I had. :-)

783
00:46:16,020 --> 00:46:20,434
So I'm really believing totally in the project

784
00:46:20,434 --> 00:46:22,075
and the success of the project.

785
00:46:22,075 --> 00:46:27,231
But I run out of money quite quickly. :-)

786
00:46:27,231 --> 00:46:30,128
Since a year ago, I'm living only on donations

787
00:46:30,128 --> 00:46:33,280
that users and followers are sending to me.

788
00:46:33,280 --> 00:46:35,522
So I want to thank them a lot

789
00:46:35,522 --> 00:46:39,136
because I wouldn't be here without them

790
00:46:39,136 --> 00:46:41,448
and Red wouldn't be at this stage

791
00:46:41,448 --> 00:46:42,987
or probably wouldn't be existing

792
00:46:42,987 --> 00:46:45,865
if people weren't supporting me.

793
00:46:45,865 --> 00:46:49,165
So thanks a lot, and we need to continue

794
00:46:49,165 --> 00:46:52,832
to support it to make it a reality.

795
00:46:52,832 --> 00:46:55,053
Thank you all for listening.

796
00:46:55,053 --> 00:46:59,053
(applause)
